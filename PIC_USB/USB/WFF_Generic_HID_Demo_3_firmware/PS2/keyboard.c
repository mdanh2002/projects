
//---------------------------------------------------------------------------------

// keyboard.c

// Keyboard routine taken mostly from AVR313. It handles the logic of the keyboard,
// not the character translation. That is done in scancodes.c.

//---------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <p18F4550.h>
#include "keycodes.h"
#include "scancodes.h"
#include "keyboard.h"
#include <delays.h>

#define MAX_KEYS 8

#define LAMP_SCROLL 0
#define LAMP_NUM 1
#define LAMP_CAPS 2

unsigned char _bitCount;
unsigned char _sending;
unsigned char _lamps;
unsigned char flags = 0;
unsigned char keyBuffer[MAX_KEYS];
unsigned char * inPtr, * outPtr, * endPtr;
unsigned char dataRecv = 0;

// calculate the parity of a given byte (odd parity)
unsigned char parity(unsigned char ino)
{
	unsigned char noofones = 0;
	unsigned char mask = 0b00000001; /* start at first bit */

	while(mask != 0) /* until all bits tested */
	{
		if(mask & ino) /* if bit is 1, increment noofones */
		{
			noofones++;
		}
		mask = mask << 1; /* go to next bit */
	}

	// using odd parity, the parity bit is set to 1 
	// if the number of ones in a given set of bits (not including the parity bit) is even
	return (1 - noofones & 1); 
}

void putKey( unsigned char key )
{
	*inPtr = key;
	if ( ++inPtr == endPtr )
		inPtr = keyBuffer;
	if ( inPtr == outPtr )
		if ( ++outPtr == endPtr )
			outPtr = keyBuffer;
}

unsigned char getKey( void )
{
	unsigned char key = '\0';

	if ( outPtr == endPtr )
		outPtr = keyBuffer;
	if ( outPtr != inPtr )
		key = *outPtr++;
	return key;
}

void decode( unsigned char data )
{
	unsigned char chr;
	
	// If we did not just receive the up (0xf0) code, we must have a keypress.
	if (( flags & UP_FLAG ) == 0 )
	{
		// Is it the up code?
		if ( data == 0xf0 )
		{
			flags |= UP_FLAG;
		}
		// Shift?
		else if (( data == 0x12 ) || ( data == 0x59 ))
		{
			flags |= SHIFT_FLAG;
		}
		// Caps Lock?
		else if ( data == 0x58 )
		{
			flags ^= CLOCK_FLAG;
		}
		// Control? There is only one control key on my keyboard.
		else if ( data == 0x14 )
		{
			flags |= CTL_FLAG;
		}
		// Alternate? Both return the same code on this keyboard.
		else if ( data == 0x11 )
		{
			flags |= ALT_FLAG;
		}
		// Extended code. There are no non-unique extended codes on this keyboard.
		else if ( data == 0xe0 )
		{
			return;
		}
		// Display or use the character.
		else
		{
			// Convert the character to ASCII.
			if (( chr = decodeScanCode( data, flags )) != 0 )
			{
				putKey( chr );
			}
		}
	}
	else
	{
		// If the up code is active, it becomes inactive after any key.
		flags &= ~UP_FLAG;

		// Shift key up? Reset the shift.
		if (( data == 0x12 ) || ( data == 0x59 ))
		{
			flags &= ~SHIFT_FLAG;
		}
		// Control key up? Reset control.
		else if ( data == 0x14 )
		{
			flags &= ~CTL_FLAG;
		}
		// Alt key up? reset alternate.
		else if ( data == 0x11 )
		{
			flags &= ~ALT_FLAG;
		}
	}
}

//---------------------------------------------------------------------------------

// keyboardInit( )

//---------------------------------------------------------------------------------

void keyboardInit( void )
{
   _bitCount = 11;		// Get 11 bits from the keyboard.

	// input for data and clock line
	KB_DATA_DIR = 1;
	KB_CLK_DIR = 1;

	// interrupt procedure from http://www.mikroe.com/forum/viewtopic.php?p=89395
	// Clock line (generated by keyboard when a key is pressed) is connected to INT0
    // when main code catches the interrupt, it will call processKeyboardISR to
	// process the key pressed and placed into the keyboard buffer
   RCONbits.IPEN = 1; //enable priority levels on interrupts
   IPR1bits.RCIP = 0; //sets USART receive interrupt to low priority
   INTCONbits.GIEH = 1; //enable all high-priority interrupts
   INTCONbits.GIEL = 1; //enable all low-priority interrupts
   INTCON2bits.INTEDG0 = 0;// Setup INT0 for the falling edge.
   INTCONbits.INT0IE = 1; //enable INT0 external interrupt
   INTCON3bits.INT1IE = 0; //disable INT1 external interrupt
   INTCON3bits.INT2IE = 0; //disable INT2 external interrupt

   inPtr = outPtr = keyBuffer;
   endPtr = inPtr + (MAX_KEYS);
}

//---------------------------------------------------------------------------------

// INT0 is the clock that is used to strobe the keyboard data. It is supplied by
// the keyboard.

//---------------------------------------------------------------------------------

void processKeyboardISR(void)
{
	// PS2 protocol from http://www.computer-engineering.org/ps2protocol/
	// Data from device (e.g. keyboard) to host (e.g. computer to PIC) is read on the falling edge
	if ( _bitCount < 11 && _bitCount > 2 )
	{
		dataRecv = ( dataRecv >> 1 );	// Shift the data over.
		if ( PORTAbits.RA3 )
			dataRecv |= 0x80;	// Add a bit if it is a one.
	}

	if( --_bitCount == 0 )		// All bits received?
	{
		decode( dataRecv );		// Figure out what it is.
		_bitCount = 11;		// Start over.

		dataRecv = 0;
	}
}

// Send a PS2 command to the keyboard controller
// http://www.computer-engineering.org/ps2protocol/
// if waitForResponse = 0, do not wait for the keyboard response
// if waitForResponse = 1, wait for a byte response from the keyboard
// if waitForResponse = 2, wait for 2 byte response from the keyboard
unsigned int sendKeyboardCommand(unsigned char command, unsigned char waitForResponse)
{
	unsigned char x = 0;
	unsigned char bitCount = 0;
	unsigned char response1 = 0;
	unsigned char response2 = 0;

	// disable the interrupt for keyboard input
	INTCONbits.INT0IE = 0;

    // 1)   Bring the Clock line low for at least 100 microseconds (START bit)
	KB_CLK_DIR = 0;
	KB_CLK_OUT = 0;
	Delay10TCYx (65); //110uS

    // 2)   Bring the Data line low.
	KB_DATA_DIR = 0;
	KB_DATA_OUT = 0;

    // 3)   Release the Clock line.
	KB_CLK_OUT = 1;
	KB_CLK_DIR = 1;

    // 4)   Wait for the device to bring the Clock line low.
	while (KB_CLK_IN == 1);

	// 5)  Clock the byte out with 1 parity bit and 1 stop bit
    for(x=0;x<10;x++){       
		if (x<8)
		{
			// data bit
        	if(command & 1)
    	        KB_DATA_OUT = 1;
			else
    	        KB_DATA_OUT = 0;

	        command >>= 1;
		}
		else if (x==8)
		{
			// parity bit, odd parity
			unsigned char p;
			p = parity(command);

        	if(p > 0)
    	        KB_DATA_OUT = 1;
			else
    	        KB_DATA_OUT = 0;
		}
		else if (x==9)
		{
			// stop bit
			KB_DATA_OUT = 1;
		}
		
    	// 6)   Wait for the device to produce 1 clock pulse, e.g. high and low
		while (KB_CLK_IN == 0);
		while (KB_CLK_IN == 1);
    }
	
    // 7)   Release the Data line.
	KB_DATA_OUT = 1;
	KB_DATA_DIR = 1;

    // 8) Wait for the device to bring Data low. (ACK bit)
	while (KB_DATA_IN == 1);

    // 12) Wait for the device to release Data and Clock
	while (KB_DATA_IN == 0);
	while (KB_CLK_IN == 0);

	for (x=0;x<waitForResponse;x++)
	{
		while (bitCount < 11)
		{
			// wait until clock is low
			while (KB_CLK_IN == 1);

			// ignore parity and stop bit
			if (bitCount >= 1 && bitCount <=8)
			{
				if (KB_DATA_IN)
				{
					if (x==0)
					{
						// first byte response
						response1 |= (1 << (bitCount - 1));
					}
					else
					{
						// second byte response
						response2  |= (1 << (bitCount - 1));
					}
				}
			}

			bitCount++;

			// wait until clock is high
			while (KB_CLK_IN == 0);
		}

		// delay for last byte received
		if (x == waitForResponse-1)
		{
			// Delay10KTCYx(1); 
		}

		bitCount = 0;

		// keyb responds with invalid command, do not get next byte
		if (response1 == 0xFE)
		{
			// Delay10KTCYx(1); 
			break;
		}
	}

	// just wait a while for data line to be stable
	// Delay10KTCYx(2); 

	// Enable the interrupt for keyboard input
	INTCONbits.INT0IE = 1;
	
	return (((int)response2 << 8) + (int)response1);
}
